function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var LENGTH_UNIT = /(em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|q|in|pt|pc|px|dpi|dpcm|dppx|%|auto)$/i;
var CALC = /^(calc\()/i;
var VAR = /^(var\()/i;
var BORDER_STYLE = /^(dashed|dotted|double|groove|hidden|inset|none|outset|ridge|solid)$/i;
var BORDER_WIDTH = /^(thick|medium|think)$/i;
var PURE_NUMBER = /^\d+$/;
var GLOBAL_VALUES = ['inherit', 'initial', 'unset', 'revert', 'revert-layer'];

function splitShorthand(value) {
  var values = [''];
  var openParensCount = 0;
  var trimmedValue = value.trim();

  for (var index = 0; index < trimmedValue.length; index += 1) {
    if (trimmedValue.charAt(index) === ' ' && openParensCount === 0) {
      // Add new value
      values.push('');
    } else {
      // Add the current character to the current value
      values[values.length - 1] = values[values.length - 1] + trimmedValue.charAt(index);
    } // Keep track of the number of parentheses that are yet to be closed.
    // This is done to avoid splitting at whitespaces within CSS functions.
    // E.g.: `calc(1px + 1em)`


    if (trimmedValue.charAt(index) === '(') {
      openParensCount++;
    } else if (trimmedValue.charAt(index) === ')') {
      openParensCount--;
    }
  }

  return values;
}

function parseBorder(value, resolve) {
  var values = splitShorthand(value);
  var longhands = {};
  values.forEach(function (val) {
    if (val.match(BORDER_STYLE) !== null) {
      longhands[resolve('Style')] = val;
    } else if (val.match(BORDER_WIDTH) !== null || val.match(LENGTH_UNIT) !== null || val.match(CALC) !== null || val === '0') {
      longhands[resolve('Width')] = val;
    } else {
      longhands[resolve('Color')] = val;
    }
  });
  return longhands;
}

function parseCircular(value, resolve) {
  var _ref;

  var _splitShorthand = splitShorthand(value),
      _splitShorthand2 = _slicedToArray(_splitShorthand, 4),
      Top = _splitShorthand2[0],
      _splitShorthand2$ = _splitShorthand2[1],
      Right = _splitShorthand2$ === void 0 ? Top : _splitShorthand2$,
      _splitShorthand2$2 = _splitShorthand2[2],
      Bottom = _splitShorthand2$2 === void 0 ? Top : _splitShorthand2$2,
      _splitShorthand2$3 = _splitShorthand2[3],
      Left = _splitShorthand2$3 === void 0 ? Right : _splitShorthand2$3;

  return _ref = {}, _defineProperty(_ref, resolve('Top'), Top), _defineProperty(_ref, resolve('Right'), Right), _defineProperty(_ref, resolve('Bottom'), Bottom), _defineProperty(_ref, resolve('Left'), Left), _ref;
}

function parseFlowRelativePosition(value, resolve) {
  var _ref2;

  var _splitShorthand3 = splitShorthand(value),
      _splitShorthand4 = _slicedToArray(_splitShorthand3, 2),
      Start = _splitShorthand4[0],
      _splitShorthand4$ = _splitShorthand4[1],
      End = _splitShorthand4$ === void 0 ? Start : _splitShorthand4$;

  return _ref2 = {}, _defineProperty(_ref2, resolve('Start'), Start), _defineProperty(_ref2, resolve('End'), End), _ref2;
}

function groupBy(values, divider) {
  var groups = [[]];
  values.forEach(function (val) {
    if (val === divider) {
      groups.push([]);
    } else {
      groups[groups.length - 1].push(val);
    }
  });
  return groups;
}

function parseBorderRadius(value) {
  var _groupBy = groupBy(splitShorthand(value), '/'),
      _groupBy2 = _slicedToArray(_groupBy, 2),
      _groupBy2$ = _groupBy2[0],
      first = _groupBy2$ === void 0 ? [] : _groupBy2$,
      _groupBy2$2 = _groupBy2[1],
      second = _groupBy2$2 === void 0 ? [] : _groupBy2$2;

  var _first = _slicedToArray(first, 4),
      Top = _first[0],
      _first$ = _first[1],
      Right = _first$ === void 0 ? Top : _first$,
      _first$2 = _first[2],
      Bottom = _first$2 === void 0 ? Top : _first$2,
      _first$3 = _first[3],
      Left = _first$3 === void 0 ? Right : _first$3;

  var _second = _slicedToArray(second, 4),
      Top2 = _second[0],
      _second$ = _second[1],
      Right2 = _second$ === void 0 ? Top2 : _second$,
      _second$2 = _second[2],
      Bottom2 = _second$2 === void 0 ? Top2 : _second$2,
      _second$3 = _second[3],
      Left2 = _second$3 === void 0 ? Right2 : _second$3;

  return {
    borderTopLeftRadius: [Top, Top2].filter(Boolean).join(' '),
    borderTopRightRadius: [Right, Right2].filter(Boolean).join(' '),
    borderBottomRightRadius: [Bottom, Bottom2].filter(Boolean).join(' '),
    borderBottomLeftRadius: [Left, Left2].filter(Boolean).join(' ')
  };
}

var textDecorationLineValues = new Set(GLOBAL_VALUES.concat(['none', 'underline', 'overline', 'line-through', 'blink']));
var textDecorationStyleValues = new Set(GLOBAL_VALUES.concat(['solid', 'double', 'dotted', 'dashed', 'wavy']));

function parseTextDecoration(value) {
  // https://www.w3.org/TR/css-text-decor-3/#text-decoration-property
  // https://w3c.github.io/csswg-drafts/css-text-decor/#text-decoration-property
  var values = splitShorthand(value);

  if (values.length === 1) {
    // A text-decoration declaration that omits both the text-decoration-color and text-decoration-style
    // values is backwards-compatible with CSS Levels 1 and 2.
    if (values[0] === 'initial') {
      return {
        textDecorationLine: 'none'
      };
    }

    return {
      textDecorationLine: values[0]
    };
  }

  var _values = _slicedToArray(values, 3),
      left = _values[0],
      middle = _values[1],
      right = _values[2];

  var lineValue = [];
  var colorValue = '';
  var styleValue = '';

  var extractValues = function extractValues(v) {
    if (v) {
      if (textDecorationLineValues.has(v)) {
        if (lineValue.length === 0 || !lineValue.includes(v)) {
          lineValue.push(v);
        } else {
          // Repeated line value, invalid, bail out!
          return true;
        }
      } else if (textDecorationStyleValues.has(v)) {
        styleValue = v;
      } else {
        colorValue = v;
      }
    } // Valid, continue


    return false;
  };

  if (extractValues(left) || extractValues(middle) || extractValues(right)) {
    // Invalid, ignore
    return {};
  }

  lineValue.sort(); // Ensure the sorting is always in the same order.

  var textDecorationLine = lineValue.length ? lineValue.join(' ') : 'none';
  return {
    textDecorationLine: textDecorationLine,
    textDecorationStyle: styleValue || 'solid',
    textDecorationColor: colorValue || 'currentColor'
  };
}

var circularExpand = {
  borderWidth: function borderWidth(key) {
    return 'border' + key + 'Width';
  },
  borderColor: function borderColor(key) {
    return 'border' + key + 'Color';
  },
  borderStyle: function borderStyle(key) {
    return 'border' + key + 'Style';
  },
  padding: function padding(key) {
    return 'padding' + key;
  },
  margin: function margin(key) {
    return 'margin' + key;
  },
  scrollPadding: function scrollPadding(key) {
    return 'scrollPadding' + key;
  },
  scrollMargin: function scrollMargin(key) {
    return 'scrollMargin' + key;
  }
};
var borderExpand = {
  borderLeft: function borderLeft(key) {
    return 'borderLeft' + key;
  },
  borderTop: function borderTop(key) {
    return 'borderTop' + key;
  },
  borderRight: function borderRight(key) {
    return 'borderRight' + key;
  },
  borderBottom: function borderBottom(key) {
    return 'borderBottom' + key;
  },
  outline: function outline(key) {
    return 'outline' + key;
  }
};
var flowRelativePositionExpand = {
  paddingInline: function paddingInline(key) {
    return 'paddingInline' + key;
  },
  paddingBlock: function paddingBlock(key) {
    return 'paddingBlock' + key;
  },
  marginInline: function marginInline(key) {
    return 'marginInline' + key;
  },
  marginBlock: function marginBlock(key) {
    return 'marginBlock' + key;
  }
};

function parseFlex(value) {
  var values = ['']; // https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values

  switch (value.trim()) {
    case 'initial':
      // "flex: initial" is equivalent to "flex: 0 1 auto"
      values = splitShorthand('0 1 auto');
      break;

    case 'auto':
      // "flex: auto" is equivalent to "flex: 1 1 auto"
      values = splitShorthand('1 1 auto');
      break;

    case 'none':
      // "flex: none" is equivalent to "flex: 0 0 auto"
      values = splitShorthand('0 0 auto');
      break;

    default:
      values = splitShorthand(value);
      break;
  } // https://developer.mozilla.org/en-US/docs/Web/CSS/flex#syntax
  // https://www.w3.org/TR/css-flexbox-1/
  // Expand one-value syntax to three-value syntax


  if (values.length === 1) {
    // One-value syntax
    var val = values[0];

    if (PURE_NUMBER.test(val)) {
      // flex value
      values = splitShorthand(val + ' 1 0');
    } else {
      // It is a width value (flex-basis)
      values = splitShorthand('1 1 ' + val);
    }
  }

  var longhands = {};

  if (values.length === 2) {
    // Two-value syntax
    longhands.flexGrow = values[0];

    if (values[1].match(PURE_NUMBER) !== null) {
      // The second value appears to be a shrink factor
      longhands.flexShrink = values[1];
    } else {
      // The second value appears to be width
      longhands.flexBasis = values[1];
    }
  } else {
    // Three-value syntax
    longhands.flexGrow = values[0];
    longhands.flexShrink = values[1];
    longhands.flexBasis = values[2];
  } // According to the spec: Authors are encouraged to control flexibility using the flex shorthand rather than with its longhand
  // properties directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
  //
  // Thus in order to maintain the correct behavior, we have to reset any unspecified longhand properties to their default values.
  // Add default value, initialized value is "0 1 auto"


  if (typeof longhands.flexGrow === 'undefined') {
    longhands.flexGrow = '0';
  }

  if (typeof longhands.flexShrink === 'undefined') {
    longhands.flexShrink = '1';
  }

  if (typeof longhands.flexBasis === 'undefined') {
    longhands.flexBasis = 'auto';
  }

  return longhands;
}

function parseOverflow(value) {
  // https://www.w3.org/TR/css-overflow-3/#overflow-properties
  // The overflow property is a shorthand property that sets the specified values of overflow-x
  // and overflow-y in that order. If the second value is omitted, it is copied from the first.
  var _splitShorthand5 = splitShorthand(value),
      _splitShorthand6 = _slicedToArray(_splitShorthand5, 2),
      overflowX = _splitShorthand6[0],
      _splitShorthand6$ = _splitShorthand6[1],
      overflowY = _splitShorthand6$ === void 0 ? overflowX : _splitShorthand6$;

  return {
    overflowX: overflowX,
    overflowY: overflowY
  };
}

function parseGap(value) {
  // https://w3c.github.io/csswg-drafts/css-align/#gap-shorthand
  var _splitShorthand7 = splitShorthand(value),
      _splitShorthand8 = _slicedToArray(_splitShorthand7, 2),
      rowGap = _splitShorthand8[0],
      _splitShorthand8$ = _splitShorthand8[1],
      columnGap = _splitShorthand8$ === void 0 ? rowGap : _splitShorthand8$; // This property is a shorthand that sets row-gap and column-gap in one declaration. If <'column-gap'> is omitted, it’s set to the same value as <'row-gap'>.


  return {
    rowGap: rowGap,
    columnGap: columnGap
  };
}

var flexDirectionValues = new Set(GLOBAL_VALUES.concat(['row', 'row-reverse', 'column', 'column-reverse']));
var flexWrapValues = new Set(GLOBAL_VALUES.concat(['nowrap', 'wrap', 'reverse']));

function parseFlexFlow(value) {
  // https://w3c.github.io/csswg-drafts/css-flexbox/#flex-flow-property
  // initial value is specified individually for each of the flex-direction and flex-wrap properties
  var flexDirection = '';
  var flexWrap = '';

  var _splitShorthand9 = splitShorthand(value),
      _splitShorthand10 = _slicedToArray(_splitShorthand9, 2),
      left = _splitShorthand10[0],
      right = _splitShorthand10[1];

  var extractFlexFlowValue = function extractFlexFlowValue(value) {
    if (value) {
      if (flexDirectionValues.has(value)) {
        if (flexDirection !== '') {
          // flex-direction has already been set, original value invalid
          return true;
        }

        flexDirection = value;
      } else if (flexWrapValues.has(value)) {
        if (flexWrap !== '') {
          // flex-wrap has already been set, original value invalid
          return true;
        }

        flexWrap = value;
      } else {
        // invalid value
        return true;
      }
    }

    return false;
  };

  if (extractFlexFlowValue(left) || extractFlexFlowValue(right)) {
    // invalid value, ignore both values
    return {};
  }

  return {
    // only fallback to default value when original value is valid
    flexDirection: flexDirection || 'row',
    flexWrap: flexWrap || 'nowrap'
  };
} // https://w3c.github.io/csswg-drafts/css-align/#place-content


function parsePlaceContent(value) {
  // The first value is assigned to align-content.
  // The second value is assigned to justify-content
  var _splitShorthand11 = splitShorthand(value),
      _splitShorthand12 = _slicedToArray(_splitShorthand11, 2),
      alignContent = _splitShorthand12[0],
      justifyContent = _splitShorthand12[1];

  if (!justifyContent && alignContent) {
    // if omitted, ...
    if (alignContent === 'left' || alignContent === 'right' || alignContent === 'first' || alignContent === 'last') {
      // invalid value, ignore both values
      return {};
    }

    if (alignContent === 'baseline') {
      // ..., unless that value is a <baseline-position> in which case it is defaulted to start.
      justifyContent = 'start';
    } else {
      // ..., it is copied from the first value
      justifyContent = alignContent;
    }
  }

  return {
    alignContent: alignContent,
    justifyContent: justifyContent
  };
} // https://w3c.github.io/csswg-drafts/css-align/#place-items-property


function parsePlaceItems(value) {
  // This shorthand property sets both the align-items and justify-items properties in a single declaration. The first value is assigned to align-items. The second value is assigned to justify-items; if omitted, it is copied from the first value.
  var _splitShorthand13 = splitShorthand(value),
      _splitShorthand14 = _slicedToArray(_splitShorthand13, 2),
      alignItems = _splitShorthand14[0],
      _splitShorthand14$ = _splitShorthand14[1],
      justifyItems = _splitShorthand14$ === void 0 ? alignItems : _splitShorthand14$;

  return {
    alignItems: alignItems,
    justifyItems: justifyItems
  };
}

function parsePlaceSelf(value) {
  // https://w3c.github.io/csswg-drafts/css-align/#place-self-property
  var _splitShorthand15 = splitShorthand(value),
      _splitShorthand16 = _slicedToArray(_splitShorthand15, 2),
      alignSelf = _splitShorthand16[0],
      _splitShorthand16$ = _splitShorthand16[1],
      justifySelf = _splitShorthand16$ === void 0 ? alignSelf : _splitShorthand16$;

  return {
    alignSelf: alignSelf,
    justifySelf: justifySelf
  };
} // https://w3c.github.io/csswg-drafts/css-transitions/#transition-shorthand-property
// Since transition can accept multiple values, we will run extraction on each value


var extractTransition = function extractTransition(value) {
  var values = splitShorthand(value);

  if (values.length === 1) {
    if (GLOBAL_VALUES.includes(values[0])) {
      return {
        transitionProperty: values[0],
        transitionDuration: values[0],
        transitionDelay: values[0],
        transitionTimingFunction: values[0]
      };
    } else if (values[0] === 'all' || values[0] === 'none') {
      return {
        transitionProperty: values[0],
        transitionDuration: '0s',
        // https://w3c.github.io/csswg-drafts/css-transitions/#transition-duration-property
        transitionDelay: '0s',
        // https://w3c.github.io/csswg-drafts/css-transitions/#transition-delay-property
        transitionTimingFunction: 'ease' // https://w3c.github.io/csswg-drafts/css-transitions/#transition-timing-function-property

      };
    }
  } // Note that order is important within the items in this property: the first value that can be parsed as a time is assigned to the transition-duration, and the second value that can be parsed as a time is assigned to transition-delay.


  var _values2 = _slicedToArray(values, 4),
      transitionProperty = _values2[0],
      _values2$ = _values2[1],
      transitionDuration = _values2$ === void 0 ? '0s' : _values2$,
      _values2$2 = _values2[2],
      transitionDelay = _values2$2 === void 0 ? '0s' : _values2$2,
      _values2$3 = _values2[3],
      transitionTimingFunction = _values2$3 === void 0 ? 'ease' : _values2$3;

  return {
    transitionProperty: transitionProperty,
    transitionDuration: transitionDuration,
    transitionDelay: transitionDelay,
    transitionTimingFunction: transitionTimingFunction
  };
}; // https://w3c.github.io/csswg-drafts/css-transitions/#transition-shorthand-property


function parseTransition(value) {
  if (!value.includes(',')) {
    // single value, let's do fast path
    return extractTransition(value);
  }

  var transitions = value.split(',').map(extractTransition); // merge multiple transitions
  // See https://developer.mozilla.org/en-US/docs/Web/CSS/transition#syntax for examples
  // The merge is adapted from microsoft/griffel, which is also an Atomic CSS-in-JS library
  // https://github.com/microsoft/griffel/blob/76662f70e846523bd1ab663f3340d4906333c795/packages/core/src/shorthands/transition.ts#LL64-L80C5

  return transitions.reduce(function (acc, _ref3, index) {
    var transitionProperty = _ref3.transitionProperty,
        transitionDuration = _ref3.transitionDuration,
        transitionDelay = _ref3.transitionDelay,
        transitionTimingFunction = _ref3.transitionTimingFunction;

    if (index === 0) {
      acc.transitionProperty = transitionProperty;
      acc.transitionDuration = transitionDuration;
      acc.transitionDelay = transitionDelay;
      acc.transitionTimingFunction = transitionTimingFunction;
    } else {
      acc.transitionProperty += ", ".concat(transitionProperty);
      acc.transitionDuration += ", ".concat(transitionDuration);
      acc.transitionDelay += ", ".concat(transitionDelay);
      acc.transitionTimingFunction += ", ".concat(transitionTimingFunction);
    }

    return acc;
  }, {});
}

function parseInset(value) {
  var _splitShorthand17 = splitShorthand(value),
      _splitShorthand18 = _slicedToArray(_splitShorthand17, 4),
      top = _splitShorthand18[0],
      _splitShorthand18$ = _splitShorthand18[1],
      right = _splitShorthand18$ === void 0 ? top : _splitShorthand18$,
      _splitShorthand18$2 = _splitShorthand18[2],
      bottom = _splitShorthand18$2 === void 0 ? top : _splitShorthand18$2,
      _splitShorthand18$3 = _splitShorthand18[3],
      left = _splitShorthand18$3 === void 0 ? right : _splitShorthand18$3;

  return {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
}

function expandProperty(property, value) {
  // special expansion for the border property as its 2 levels deep
  if (property === 'border') {
    var longhands = parseBorder(value.toString(), function (key) {
      return 'border' + key;
    });
    var result = {};

    for (var _property in longhands) {
      Object.assign(result, expandProperty(_property, longhands[_property]));
    }

    return result;
  }

  if (property === 'flex') {
    return parseFlex(value.toString());
  }

  if (property === 'borderRadius') {
    return parseBorderRadius(value.toString());
  }

  if (property === 'textDecoration') {
    return parseTextDecoration(value.toString());
  }

  if (property === 'overflow') {
    return parseOverflow(value.toString());
  }

  if (property === 'gap') {
    return parseGap(value.toString());
  }

  if (property === 'flexFlow') {
    return parseFlexFlow(value.toString());
  }

  if (property === 'placeContent') {
    return parsePlaceContent(value.toString());
  }

  if (property === 'placeItems') {
    return parsePlaceItems(value.toString());
  }

  if (property === 'placeSelf') {
    return parsePlaceSelf(value.toString());
  }

  if (property === 'transition') {
    return parseTransition(value.toString());
  }

  if (property === 'inset') {
    return parseInset(value.toString());
  }

  if (circularExpand[property]) {
    return parseCircular(value.toString(), circularExpand[property]);
  }

  if (borderExpand[property]) {
    return parseBorder(value.toString(), borderExpand[property]);
  }

  if (flowRelativePositionExpand[property]) {
    return parseFlowRelativePosition(value.toString(), flowRelativePositionExpand[property]);
  }
}

export default function preExpand(property, value) {
  if (Array.isArray(value)) {
    var result = {};
    value.forEach(function (item) {
      var itemResult = expandProperty(property, item);

      if (itemResult) {
        Object.keys(itemResult).forEach(function (itemProperty) {
          result[itemProperty] = result[itemProperty] || [];
          result[itemProperty].push(itemResult[itemProperty]);
        });
      }
    });

    if (Object.keys(result).length) {
      return result;
    }

    return null;
  }

  return expandProperty(property, value);
}